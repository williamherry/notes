## get start

    git clone https://github.com/rails/rails.git

    which rails
    => /home/william/.rvm/gems/ruby-2.4.0/bin/rails

### /home/william/.rvm/gems/ruby-2.4.0/bin/rails
    #!/usr/bin/env ruby_executable_hooks                                                                                                                                                                        
    #
    # This file was generated by RubyGems.
    #
    # The application 'railties' is installed as part of a gem, and
    # this file is here to facilitate running it.
    #
    require 'rubygems'
    version = ">= 0.a"
    if ARGV.first
      str = ARGV.first
      str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
      if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
        version = $1
        ARGV.shift
      end
    end
    load Gem.activate_bin_path('railties', 'rails', version)

> load一次文件,文件执行一次

    puts Gem.method(:activate_bin_path).source_location
    => /home/william/.rvm/gems/ruby-2.4.0/gems/bundler-1.14.6/lib/bundler/rubygems_integration.rb:419

### /home/william/.rvm/gems/ruby-2.4.0/gems/bundler-1.14.6/lib/bundler/rubygems_integration.rb
    redefine_method(gem_class, :activate_bin_path) do |name, *args|                                                                                                                                       
        exec_name = args.first
        return ENV["BUNDLE_BIN_PATH"] if exec_name == "bundle"
        # Copy of Rubygems activate_bin_path impl
        requirement = args.last
        spec = find_spec_for_exe name, exec_name, [requirement]
        Gem::LOADED_SPECS_MUTEX.synchronize { spec.activate }
        spec.bin_file exec_name
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/exe/rails
    #!/usr/bin/env ruby                                                                                                                                                                                         
    git_path = File.expand_path("../../../.git", __FILE__)
    if File.exist?(git_path)
      railties_path = File.expand_path("../../lib", __FILE__)
      $:.unshift(railties_path)
    end
    require "rails/cli"
    
    where is the "rails/cli"
    
### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/cli.rb
    
    require "rails/app_loader"                                                                                                                                                                                  
    # If we are inside a Rails application this method performs an exec and thus
    # the rest of this script is not run.
    Rails::AppLoader.exec_app
    require "rails/ruby_version_check"
    Signal.trap("INT") { puts; exit(1) }
    require "rails/command"
    if ARGV.first == "plugin"
      ARGV.shift
      Rails::Command.invoke :plugin, ARGV
    else
      Rails::Command.invoke :application, ARGV
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/app_loader.rb
    def exec_app
      original_cwd = Dir.pwd
      loop do
        if exe = find_executable
          contents = File.read(exe)
          if contents =~ /(APP|ENGINE)_PATH/
            exec RUBY, exe, *ARGV
            break # non reachable, hack to be able to stub exec in the test suite
          elsif exe.end_with?("bin/rails") && contents.include?("This file was generated by Bundler")
            $stderr.puts(BUNDLER_WARNING)
            Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
            require File.expand_path("../boot", APP_PATH)
            require "rails/commands"
            break
          end
        end
        # If we exhaust the search there is no executable, this could be a
        # call to generate a new application, so restore the original cwd.
        Dir.chdir(original_cwd) && return if Pathname.new(Dir.pwd).root?
        # Otherwise keep moving upwards in search of an executable.
        Dir.chdir("..")
      end
    end

    exe => bin/rails
    
### bin/rails
    #!/usr/bin/env ruby
    begin
      load File.expand_path('../spring', __FILE__)
    rescue LoadError => e
      raise unless e.message.include?('spring')
    end
    APP_PATH = File.expand_path('../config/application', __dir__)                                                                                                                                               
    require_relative '../config/boot'
    require 'rails/commands'

### bin/spring
    #!/usr/bin/env ruby
    # This file loads spring without using Bundler, in order to be fast.
    # It gets overwritten when you run the `spring binstub` command.
    unless defined?(Spring)
      require 'rubygems'
      require 'bundler'
      lockfile = Bundler::LockfileParser.new(Bundler.default_lockfile.read)
      spring = lockfile.specs.detect { |spec| spec.name == "spring" }
      if spring
        Gem.use_paths Gem.dir, Bundler.bundle_path.to_s, *Gem.path
        gem 'spring', spring.version
        require 'spring/binstub'
      end
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/commands.rb

    require "rails/command"
    aliases = {
      "g"  => "generate",
      "d"  => "destroy",
      "c"  => "console",
      "s"  => "server",
      "db" => "dbconsole",
      "r"  => "runner",
      "t"  => "test"
    }
    command = ARGV.shift
    command = aliases[command] || command
    Rails::Command.invoke command, ARGV

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/commands/server/server_command.rb
    def start                                                                                                                     print_boot_information
      trap(:INT) { exit }
      create_tmp_directories
      setup_dev_caching
      log_to_stdout if options[:log_stdout]
      super
    ensure
      # The '-h' option calls exit before @options is set.
      # If we call 'options' with it unset, we get double help banners.
      puts "Exiting" unless @options && options[:daemonize]
    end

    module Rails
       class Server < ::Rack::Server                                                                                    
       end
    end


    # puts server
    Rack::Handler::Puma

### /home/william/.rvm/gems/ruby-2.4.0/gems/rack-2.0.3/lib/rack/server.rb

    def start &blk
      if options[:warn]
        $-w = true
      end
      if includes = options[:include]
        $LOAD_PATH.unshift(*includes)
      end
      if library = options[:require]
        require library
      end
      if options[:debug]
        $DEBUG = true
        require 'pp'
        p options[:server]
        pp wrapped_app
        pp app
      end
      check_pid! if options[:pid]
      # Touch the wrapped app, so that the config.ru is loaded before
      # daemonization (i.e. before chdir, etc).
      wrapped_app
      daemonize_app if options[:daemonize]
      write_pid if options[:pid]
      trap(:INT) do
        if server.respond_to?(:shutdown)
          server.shutdown
        else
          exit
        end
      end
      puts server                                                                                                                                                                                           
      server.run wrapped_app, options, &blk
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/puma-3.10.0/lib/rack/handler/puma.rb
    def self.run(app, options = {})
        conf   = self.config(app, options)
        
        events = options.delete(:Silent) ? ::Puma::Events.strings : ::Puma::Events.stdio
        
        launcher = ::Puma::Launcher.new(conf, :events => events)
        
        yield launcher if block_given?
        begin
          launcher.run
        rescue Interrupt
          puts "* Gracefully stopping, waiting for requests to finish"
          launcher.stop
          puts "* Goodbye!"
        end
    end  
### /home/william/.rvm/gems/ruby-2.4.0/gems/puma-3.10.0/lib/puma/launcher.rb
    def run
      previous_env =
        if defined?(Bundler)
          env = Bundler::ORIGINAL_ENV.dup
          # add -rbundler/setup so we load from Gemfile when restarting
          bundle = "-rbundler/setup"
          env["RUBYOPT"] = [env["RUBYOPT"], bundle].join(" ") unless env["RUBYOPT"].to_s.include?(bundle)
          env
        else
          ENV.to_h
        end

      @config.clamp

      @config.plugins.fire_starts self

      setup_signals
      set_process_title
      @runner.run

      case @status
      when :halt
        log "* Stopping immediately!"
      when :run, :stop
        graceful_stop
      when :restart
        log "* Restarting..."
        ENV.replace(previous_env)
        @runner.before_restart
        restart!
      when :exit
        # nothing
      end
    end
### /home/william/.rvm/gems/ruby-2.4.0/gems/puma-3.10.0/lib/puma/single.rb
    def run
      already_daemon = false

      if jruby_daemon?
        require 'puma/jruby_restart'

        if JRubyRestart.daemon?
          # load and bind before redirecting IO so errors show up on stdout/stderr
          load_and_bind
          redirect_io
        end

        already_daemon = JRubyRestart.daemon_init
      end

      output_header "single"

      if jruby_daemon?
        if already_daemon
          JRubyRestart.perm_daemonize
        else
          pid = nil

          Signal.trap "SIGUSR2" do
            log "* Started new process #{pid} as daemon..."

            # Must use exit! so we don't unwind and run the ensures
            # that will be run by the new child (such as deleting the
            # pidfile)
            exit!(true)
          end

          Signal.trap "SIGCHLD" do
            log "! Error starting new process as daemon, exiting"
            exit 1
          end

          jruby_daemon_start
          sleep
        end
      else
        if daemon?
          log "* Daemonizing..."
          Process.daemon(true)
          redirect_io
        end

        load_and_bind
      end

      Plugins.fire_background

      @launcher.write_state

      start_control

      @server = server = start_server

      unless daemon?
        log "Use Ctrl-C to stop"
        redirect_io
      end

      @launcher.events.fire_on_booted!

      begin
        server.run.join
      rescue Interrupt
        # Swallow it
      end
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/puma-3.10.0/lib/puma/runner.rb
    def load_and_bind                                                                                                                                                                                       
      unless @launcher.config.app_configured?
        error "No application configured, nothing to run"
        exit 1
      end

      # Load the app before we daemonize.
      begin
        @app = @launcher.config.app
      rescue Exception => e
        log "! Unable to load application: #{e.class}: #{e.message}"
        raise e
      end

      @launcher.binder.parse @options[:binds], self
    end

    def start_server
      min_t = @options[:min_threads]
      max_t = @options[:max_threads]

      server = Puma::Server.new app, @launcher.events, @options
      server.min_threads = min_t
      server.max_threads = max_t
      server.inherit_binder @launcher.binder

      if @options[:mode] == :tcp
        server.tcp_mode!
      end

      unless development?
        server.leak_stack_on_error = false
      end

      server
    end



* actioncable
* actionmailer
* actionpack
* actionview
* activejob
* activemodel
* activerecord
* activestorage
* activesuppoert


