## get start

    git clone https://github.com/rails/rails.git

    which rails
    => /home/william/.rvm/gems/ruby-2.4.0/bin/rails

### /home/william/.rvm/gems/ruby-2.4.0/bin/rails
    #!/usr/bin/env ruby_executable_hooks                                                                                                                                                                        
    #
    # This file was generated by RubyGems.
    #
    # The application 'railties' is installed as part of a gem, and
    # this file is here to facilitate running it.
    #
    require 'rubygems'
    version = ">= 0.a"
    if ARGV.first
      str = ARGV.first
      str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
      if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
        version = $1
        ARGV.shift
      end
    end
    load Gem.activate_bin_path('railties', 'rails', version)

> load一次文件,文件执行一次

    puts Gem.method(:activate_bin_path).source_location
    => /home/william/.rvm/gems/ruby-2.4.0/gems/bundler-1.14.6/lib/bundler/rubygems_integration.rb:419

### /home/william/.rvm/gems/ruby-2.4.0/gems/bundler-1.14.6/lib/bundler/rubygems_integration.rb
    redefine_method(gem_class, :activate_bin_path) do |name, *args|                                                                                                                                       
        exec_name = args.first
        return ENV["BUNDLE_BIN_PATH"] if exec_name == "bundle"
        # Copy of Rubygems activate_bin_path impl
        requirement = args.last
        spec = find_spec_for_exe name, exec_name, [requirement]
        Gem::LOADED_SPECS_MUTEX.synchronize { spec.activate }
        spec.bin_file exec_name
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/exe/rails
    #!/usr/bin/env ruby                                                                                                                                                                                         
    git_path = File.expand_path("../../../.git", __FILE__)
    if File.exist?(git_path)
      railties_path = File.expand_path("../../lib", __FILE__)
      $:.unshift(railties_path)
    end
    require "rails/cli"
    
    where is the "rails/cli"
    
### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/cli.rb
    
    require "rails/app_loader"                                                                                                                                                                                  
    # If we are inside a Rails application this method performs an exec and thus
    # the rest of this script is not run.
    Rails::AppLoader.exec_app
    require "rails/ruby_version_check"
    Signal.trap("INT") { puts; exit(1) }
    require "rails/command"
    if ARGV.first == "plugin"
      ARGV.shift
      Rails::Command.invoke :plugin, ARGV
    else
      Rails::Command.invoke :application, ARGV
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/app_loader.rb
    def exec_app
      original_cwd = Dir.pwd
      loop do
        if exe = find_executable
          contents = File.read(exe)
          if contents =~ /(APP|ENGINE)_PATH/
            exec RUBY, exe, *ARGV
            break # non reachable, hack to be able to stub exec in the test suite
          elsif exe.end_with?("bin/rails") && contents.include?("This file was generated by Bundler")
            $stderr.puts(BUNDLER_WARNING)
            Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
            require File.expand_path("../boot", APP_PATH)
            require "rails/commands"
            break
          end
        end
        # If we exhaust the search there is no executable, this could be a
        # call to generate a new application, so restore the original cwd.
        Dir.chdir(original_cwd) && return if Pathname.new(Dir.pwd).root?
        # Otherwise keep moving upwards in search of an executable.
        Dir.chdir("..")
      end
    end

    exe => bin/rails
    
### bin/rails
    #!/usr/bin/env ruby
    begin
      load File.expand_path('../spring', __FILE__)
    rescue LoadError => e
      raise unless e.message.include?('spring')
    end
    APP_PATH = File.expand_path('../config/application', __dir__)                                                                                                                                               
    require_relative '../config/boot'
    require 'rails/commands'

### bin/spring
    #!/usr/bin/env ruby
    # This file loads spring without using Bundler, in order to be fast.
    # It gets overwritten when you run the `spring binstub` command.
    unless defined?(Spring)
      require 'rubygems'
      require 'bundler'
      lockfile = Bundler::LockfileParser.new(Bundler.default_lockfile.read)
      spring = lockfile.specs.detect { |spec| spec.name == "spring" }
      if spring
        Gem.use_paths Gem.dir, Bundler.bundle_path.to_s, *Gem.path
        gem 'spring', spring.version
        require 'spring/binstub'
      end
    end

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/commands.rb

    require "rails/command"
    aliases = {
      "g"  => "generate",
      "d"  => "destroy",
      "c"  => "console",
      "s"  => "server",
      "db" => "dbconsole",
      "r"  => "runner",
      "t"  => "test"
    }
    command = ARGV.shift
    command = aliases[command] || command
    Rails::Command.invoke command, ARGV

### /home/william/.rvm/gems/ruby-2.4.0/gems/railties-5.1.4/lib/rails/commands/server/server_command.rb
    def start                                                                                                                     print_boot_information
      trap(:INT) { exit }
      create_tmp_directories
      setup_dev_caching
      log_to_stdout if options[:log_stdout]
      super
    ensure
      # The '-h' option calls exit before @options is set.
      # If we call 'options' with it unset, we get double help banners.
      puts "Exiting" unless @options && options[:daemonize]
    end

    module Rails
       class Server < ::Rack::Server                                                                                                                                                                             
       end
    end


    # puts server
    Rack::Handler::Puma

### /home/william/.rvm/gems/ruby-2.4.0/gems/rack-2.0.3/lib/rack/server.rb

    def start &blk
      if options[:warn]
        $-w = true
      end
      if includes = options[:include]
        $LOAD_PATH.unshift(*includes)
      end
      if library = options[:require]
        require library
      end
      if options[:debug]
        $DEBUG = true
        require 'pp'
        p options[:server]
        pp wrapped_app
        pp app
      end
      check_pid! if options[:pid]
      # Touch the wrapped app, so that the config.ru is loaded before
      # daemonization (i.e. before chdir, etc).
      wrapped_app
      daemonize_app if options[:daemonize]
      write_pid if options[:pid]
      trap(:INT) do
        if server.respond_to?(:shutdown)
          server.shutdown
        else
          exit
        end
      end
      puts server                                                                                                                                                                                           
      server.run wrapped_app, options, &blk
    end




* actioncable
* actionmailer
* actionpack
* actionview
* activejob
* activemodel
* activerecord
* activestorage
* activesuppoert


